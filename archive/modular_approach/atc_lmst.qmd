---
title: "ATC Test"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
getwd()
```

The `echo: false` option disables the printing of code (only output is displayed).

# Load packages

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(stringr)
library(readr)
library(readxl)
library(purrr)
library(plotly)
library(data.table)
library(htmlwidgets)
```

### Read atc_levels

```{r}
# read:
atc_levels <- WHO_ATC_Hierarchy_wide_2025_09_16 <- read_csv("../input/WHO_ATC_Hierarchy_wide_2025-09-16.csv")
```

### ismirsehregal's solution to get the right plotly format for a sunburst plot

Getting the correct format:

```{r}
# From ismirsehregal on Stackoverflow:

create_sunburst_data_format <- function(DF_plotly, value_column = NULL, add_root = FALSE, drop_na_nodes = TRUE){
  colNamesDF_plotly <- names(DF_plotly)
  
  if(is.data.table(DF_plotly)){
    DT <- copy(DF_plotly)
  } else {
    DT <- data.table(DF_plotly, stringsAsFactors = FALSE)
  }
  
  if(add_root){
    DT[, root := "Total"]  
  }
  
  colNamesDT <- names(DT)
  hierarchy_columns <- setdiff(colNamesDT, value_column)
  numeric_hierarchy_columns <- names(which(unlist(lapply(DT, is.numeric))))
  
  if(is.null(value_column) && add_root){
    setcolorder(DT, c("root", colNamesDF_plotly))
  } else if(!is.null(value_column) && !add_root) {
    setnames(DT, value_column, "values", skip_absent=TRUE)
    setcolorder(DT, c(setdiff(colNamesDF_plotly, value_column), "values"))
  } else if(!is.null(value_column) && add_root) {
    setnames(DT, value_column, "values", skip_absent=TRUE)
    setcolorder(DT, c("root", setdiff(colNamesDF_plotly, value_column), "values"))
  }
  
  for(current_column in setdiff(numeric_hierarchy_columns, c("root", value_column))){
    DT[, (current_column) := apply(.SD, 1, function(x){fifelse(is.na(x), yes = NA_character_, no = toTitleCase(gsub("_"," ", paste(names(x), x, sep = ": ", collapse = " | "))))}), .SDcols = current_column]
  }
  
  hierarchyList <- list()
  for(i in seq_along(hierarchy_columns)){
    current_columns <- colNamesDT[1:i]
    
    if(is.null(value_column)){
      currentDT <- unique(DT[, ..current_columns][, values := .N, by = current_columns], by = current_columns)
    } else {
      currentDT <- DT[, lapply(.SD, sum, na.rm = TRUE), by=current_columns, .SDcols = "values"]
    }
    
    setnames(currentDT, length(current_columns), "labels")
    currentDT[, depth := length(current_columns)-1]
    hierarchyList[[i]] <- currentDT
  }
  
  hierarchyDT <- rbindlist(hierarchyList, use.names = TRUE, fill = TRUE)
  
  if(drop_na_nodes){
    hierarchyDT <- na.omit(hierarchyDT, cols = "labels")
    parent_columns <- setdiff(names(hierarchyDT), c("labels", "values", "depth", value_column))
    hierarchyDT[, parents := apply(.SD, 1, function(x){fifelse(all(is.na(x)), yes = NA_character_, no = paste(x[!is.na(x)], sep = ":", collapse = " - "))}), .SDcols = parent_columns]
  } else {
    parent_columns <- setdiff(names(hierarchyDT), c("labels", "values", value_column))
    hierarchyDT[, parents := apply(.SD, 1, function(x){fifelse(x["depth"] == "0", yes = NA_character_, no = paste(x[seq(2, as.integer(x["depth"])+1)], sep = ":", collapse = " - "))}), .SDcols = parent_columns]
  }
  
  hierarchyDT[, ids := apply(.SD, 1, function(x){paste(c(if(is.na(x["parents"])){NULL}else{x["parents"]}, x["labels"]), collapse = " - ")}), .SDcols = c("parents", "labels")]
  hierarchyDT[, union(parent_columns, "depth") := NULL]
  
  return(hierarchyDT)
}

```

## EMA indications

Next it would be nice if I could add indication to the hover information:

```{r}
ema_medicines_raw <- medicines_output_medicines_en_2 <- read_excel("../input/medicines_output_medicines_en-2.xlsx", skip = 8)

ema_medicines_names <- ema_medicines_raw %>%
  janitor::clean_names()  

ema_medicines <- ema_medicines_names %>%
  rename(therapeutic_area = therapeutic_area_me_sh) %>%
  select(name_of_medicine, active_substance, atc_code_human, therapeutic_indication, therapeutic_area, marketing_authorisation_date) %>%
  mutate(active_substance = str_to_lower(active_substance), 
         therapeutic_indication = str_replace_all(therapeutic_indication, "(.{1,60})(\\s|$)", "\\1<br>"),
         marketing_authorisation_date = format(as.Date(marketing_authorisation_date, format = "%d/%m/%Y"), format = "%d/%m/%Y")) %>%
  distinct(name_of_medicine, .keep_all = TRUE) %>%
  mutate(drug_information = paste0("<b>", name_of_medicine, "</b> - centrally authorised (EMA)<Br>", "<b>Date authorised</b><Br>", marketing_authorisation_date, "<Br><b>Indication(s)</b><Br>", str_replace_all(therapeutic_area, ";", "<Br>")))
```

## DKMA data

```{r}
dkma_medicines_raw <- read_excel("../input/ListeOverGodkendteLaegemidler-2.xlsx")
```

First, try to override if I have EMA data with indication, and prepare for a rowbind.

```{r}
columns <- names(ema_medicines)

dkma_medicines <- dkma_medicines_raw %>%
  filter(!(Navn %in% ema_medicines$name_of_medicine)) %>%
  mutate(name_of_medicine = Navn,
         active_substance = str_to_lower(AktiveSubstanser),
         atc_code_human = `ATC-kode`,
         therapeutic_indication = NA,
         therapeutic_area = NA,
         marketing_authorisation_date = format(as.Date(Registreringsdato), "%d-%m-%Y"), 
         drug_information = paste0("<b>", name_of_medicine, "</b><Br>", "<b>DK registration date</b><Br>", marketing_authorisation_date)) %>%
  select(all_of(columns)) %>%
  distinct(name_of_medicine, .keep_all = TRUE)
```

Second, bind_rows

```{r}
combined_ema_dkma <- bind_rows(ema_medicines, dkma_medicines) 
saveRDS(combined_ema_dkma, file = "../output/combined_ema_dkma.RDS")



n_distinct(ema_medicines$name_of_medicine) 
n_distinct(dkma_medicines$name_of_medicine)
n_distinct(combined_ema_dkma$name_of_medicine)

```

See if I can add it to the plot:

```{r}

# two ways to join:
atc_ema_atc_join <- atc_levels %>%
  left_join(combined_ema_dkma %>% 
              select(atc_code_human, name_of_medicine) %>%
              filter(nchar(atc_code_human) == 7), 
  join_by(atc_code == atc_code_human)) %>%
  distinct(atc_code, chemical_substance, name_of_medicine, .keep_all = TRUE)

atc_ema_substance_join <- atc_levels %>%  
  left_join(combined_ema_dkma %>%
              select(name_of_medicine, active_substance), 
            join_by(chemical_substance == active_substance)) %>%
    distinct(atc_code, chemical_substance, name_of_medicine, .keep_all = TRUE)

atc_ema <- bind_rows(atc_ema_atc_join, atc_ema_substance_join) %>%
  distinct(atc_code, chemical_substance, name_of_medicine, .keep_all = TRUE)

```

```{r}
# original code version:
df <- atc_ema %>%
  mutate(value = 1) %>%
  select(atc_level_01, atc_level_03, atc_level_04, atc_level_05, atc_code, chemical_substance, name_of_medicine, value)

# text version:
df_text <- atc_ema %>%
  mutate(value = 1) %>%
  select(anatomical_main_group_01, therapeutic_subgroup_02, pharmacological_subgroup_03, chemical_subgroup_04, atc_code, chemical_substance, name_of_medicine, value)


```

```{r}
hierarchyDF <- create_sunburst_data_format(df, value_column = "value", add_root = TRUE)

# the next step is a little unusual, probably a better solution out there:
hierarchyDF_text <- create_sunburst_data_format(df_text, value_column = "value", add_root = TRUE) %>%
  mutate(
    hover_info = sapply(ids, function(x) {
      parts <- str_split(x, " - ")[[1]]   # split by " - "
      str_trim(tail(parts, 1))            # take last segment, trim spaces
    })
  ) %>%
    mutate(hover_info = str_replace(hover_info, "^(.)", toupper)) %>%
  rename(ids_text = ids)
```

```{r}
sunburst_df <- hierarchyDF %>%
  mutate(hover_info = hierarchyDF_text$hover_info,
         ids_text = hierarchyDF_text$ids_text) %>%
#  arrange(desc(labels)) %>%
  left_join(combined_ema_dkma, join_by(labels == name_of_medicine)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  mutate(hover_info = case_when(ids == "Total" ~ "ATC",
                                !is.na(drug_information) ~ drug_information,
                                .default = hover_info),
         labels = case_when(ids == "Total" ~ "ATC",
                                .default = labels)) 
```

## Original plot version, no search

...Det bliver vist lidt s√∏gt med de danske data

```{r}
p <- plot_ly(
  sunburst_df,
  ids = ~ids,
  labels = ~labels,
  parents = ~parents,
  values = ~values,
  type = "sunburst",
  branchvalues = "total",
  hovertext = ~hover_info,   # <- point to your custom column
  hoverinfo = "text", 
  sort = FALSE,
  rotation = 90)   # rotate 90 degrees clockwise, so top is north

p
```

```{r}
# Export as HTML
saveWidget(
  p_ema,
  file = "ATC_centralised_Sunburst.html",
  selfcontained = TRUE
)

message("Interactive sunburst exported to output/ATC_centralised_Sunburst.html")
```

```{r}


```

## First try: Search on ATC code only

Can I create the function I just learned?

```{r}

select_atc_level <- function(data, atc_level) {
  
  regex <- paste0(" - ", atc_level, " - ")
  data <- sunburst_df %>%
    filter(str_detect(ids, regex))
    
  p_ema <- plot_ly(
  data,
  ids = ~ids,
  labels = ~labels,
  parents = ~parents,
  values = ~values,
  type = "sunburst",
  branchvalues = "total",
  hovertext = ~hover_info,   # <- point to your custom column
  hoverinfo = "text", 
  sort = FALSE,
  rotation = 90)   # rotate 90 degrees clockwise, so top is north
  
  p_ema
}


select_atc_level(sunburst_df, "A10BJ")
```

## Second try: Search on category

```{r}
library(tidyr)

hierarchy <- sunburst_df %>%
  separate(ids_text, into = paste0("level", 1:10), sep = " - ", fill = "right")

```

```{r}


select_category_level <- function(data, text_input) {
  
  
  search_hierarchy <- function(hierarchy, term) {
  
  # Step 1: find all matches across levels
  hits <- hierarchy %>%
    filter(if_any(starts_with("level"), 
                  ~ str_detect(.x, regex(term, ignore_case = TRUE))))
  
  # Step 2: identify first unique match (search across all levels)
  first_category <- hits %>%
    pivot_longer(cols = starts_with("level"), names_to = "level", values_to = "value") %>%
    filter(str_detect(value, regex(term, ignore_case = TRUE))) %>%
    distinct(value) %>%
    slice(1) %>%
    pull(value)
  
  # Step 3: keep only rows where that category is in the hierarchy path
  hits %>%
    filter(if_any(starts_with("level"), ~ .x == first_category))
}
  
data <- search_hierarchy(hierarchy, text_input)

  p_ema <- plot_ly(
  data,
  ids = ~ids,
  labels = ~labels,
  parents = ~parents,
  values = ~values,
  type = "sunburst",
  branchvalues = "total",
  hovertext = ~hover_info,   # <- point to your custom column
  hoverinfo = "text", 
  sort = FALSE,
  rotation = 90)   # rotate 90 degrees clockwise, so top is north
  
  p_ema
}


select_category_level(hierarchy, "belladonna")
```

```{r}
data <- hierarchy %>%
  filter(if_any(starts_with("level"), ~ str_detect(.x, regex("nerv", ignore_case = TRUE))))
```

# The brilliant solution

## Dual search at the same time (= brilliant)

```{r}
hierarchy <- sunburst_df %>%
  separate(ids_text, into = paste0("level", 1:10), sep = " - ", fill = "right") %>%
  separate(ids, into = paste0("atc_level", 1:10), sep = " - ", fill = "right", remove = FALSE)
saveRDS(hierarchy, file = "../output/atc_hierarchy.rds")
```

```{r}
library(dplyr)
library(tidyr)
library(plotly)
library(stringr)

select_category_level <- function(hierarchy, text_input = NULL, atc_input = NULL) {
  
  # Internal function to search hierarchy safely
  search_hierarchy <- function(hierarchy, term_text = NULL, term_atc = NULL) {
    
    hits <- hierarchy
    
    # 1Ô∏è‚É£ Filter by text term if provided
    if (!is.null(term_text)) {
      hits <- hits %>%
        filter(if_any(starts_with("level"), ~ str_detect(.x, regex(term_text, ignore_case = TRUE))))
    }
    
    # 2Ô∏è‚É£ Filter by ATC code term if provided
    if (!is.null(term_atc)) {
      hits <- hits %>%
        filter(if_any(starts_with("atc_level"), ~ str_detect(.x, regex(term_atc, ignore_case = TRUE))))
    }
    
    # 3Ô∏è‚É£ Identify first unique match across both hierarchies
    first_category <- hits %>%
  pivot_longer(
    cols = c(starts_with("level"), starts_with("atc_level")),
    names_to = "level",
    values_to = "value"
  ) %>%
  { 
    df <- .
    # Apply str_detect only if term_text or term_atc exists
    if (!is.null(term_text) & !is.null(term_atc)) {
      df %>% filter(str_detect(value, regex(term_text, ignore_case = TRUE)) |
                    str_detect(value, regex(term_atc, ignore_case = TRUE)))
    } else if (!is.null(term_text)) {
      df %>% filter(str_detect(value, regex(term_text, ignore_case = TRUE)))
    } else if (!is.null(term_atc)) {
      df %>% filter(str_detect(value, regex(term_atc, ignore_case = TRUE)))
    } else {
      df
    }
  } %>%
  distinct(value) %>%
  slice(1) %>%
  pull(value)
    
    # 4Ô∏è‚É£ Keep only rows where that category appears in the hierarchy path
    hits %>%
      filter(if_any(c(starts_with("level"), starts_with("atc_level")), ~ .x == first_category))
  }
  
  # Apply search
  data <- search_hierarchy(hierarchy, term_text = text_input, term_atc = atc_input)
  
  # Build sunburst
  plot_ly(
    data,
    ids = ~ids,
    labels = ~labels,
    parents = ~parents,
    values = ~values,
    type = "sunburst",
    branchvalues = "total",
    hovertext = ~hover_info,
    hoverinfo = "text",
    sort = FALSE,
    rotation = 90
  )
}

# Search by text only
select_category_level(hierarchy, text_input = "diazepam")

# Search by ATC code only
select_category_level(hierarchy, atc_input = "N05BA")

# Search by both text and ATC code
select_category_level(hierarchy, text_input = "influenza", atc_input = "J07BB02")
```
