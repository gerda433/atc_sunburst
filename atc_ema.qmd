---
title: "ATC Test"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).

# Load packages

```{r}
library(dplyr)
library(stringr)
library(readr)
library(readxl)
library(purrr)
library(plotly)
library(data.table)
library(htmlwidgets)
```

# Read raw data

```{r}


# Load file originally created by Fabrício Kury :
atc_scrape_2024 <- read_csv("atc_data/WHO ATC-DDD 2024-07-31.csv") %>%
  mutate(atc_name = tolower(atc_name))

# update it with more recent info from the WHO site:

# List of Excel files
files <- c(
  "atc_data/1_temporary_and_final_atc_and_ddd_final.xlsx",
  "atc_data/atc_ddd_new_and_alterations_2025_final.xlsx"
)

# Function to read first n sheets of a file
read_first_sheets <- function(file, n_sheets = 6) {
  sheets <- excel_sheets(file)[1:n_sheets]
  sheet_list <- map(sheets, ~ read_excel(file, sheet = .x))
  names(sheet_list) <- paste0(basename(file), "_sheet", seq_along(sheet_list))
  sheet_list
}

# Read all files
all_sheets_list <- map(files, read_first_sheets) %>% flatten()

# Function to bind all sheets of a given index
bind_sheets_by_index <- function(sheet_index) {
  sheet_list <- all_sheets_list[grep(paste0("sheet", sheet_index), names(all_sheets_list))]
  bind_rows(sheet_list)
}

# Bind each sheet index into one table
combined_sheet1 <- bind_sheets_by_index(1)
combined_sheet2 <- bind_sheets_by_index(2)
combined_sheet3 <- bind_sheets_by_index(3)
combined_sheet4 <- bind_sheets_by_index(4)
combined_sheet5 <- bind_sheets_by_index(5)

# Quick check
glimpse(combined_sheet1)
glimpse(combined_sheet2)

```

# Combine raw data

```{r}
 # Create the combined new file:

atc_scrape <- bind_rows(combined_sheet1 %>% 
            select(1:2) %>%
            rename(atc_code = "New ATC code", 
                   atc_name = "Substance name"), 
          combined_sheet2 %>% 
            select(1:2) %>%
            rename(atc_code = "ATC code",
                   atc_name = "New ATC level name"),
          atc_scrape_2024)

atc_scrape_remove_previous <- atc_scrape %>%
  filter(!(atc_code %in% combined_sheet3$"Previous ATC code")) %>%
  filter(!(atc_code %in% combined_sheet4$"ATC code"))

combined_sheet3_clean <- combined_sheet3 %>% 
             select("New ATC code", "ATC level name") %>%
              rename(atc_code = "New ATC code",
                     atc_name = "ATC level name") %>%
                filter(atc_code != "deleted")

combined_sheet4_clean <- combined_sheet4 %>%
  select("ATC code", "New ATC level name") %>%
              rename(atc_code = "ATC code",
                     atc_name = "New ATC level name")


all_atc <- bind_rows(atc_scrape_remove_previous, 
                     combined_sheet3_clean, 
                     combined_sheet4_clean) %>%
  select(atc_code, atc_name) %>%
  arrange(atc_code)

# --- Save full hierarchy CSV ---
write_csv(all_atc, paste0("atc_data/WHO_ATC_Hierarchy_", Sys.Date(), ".csv"))
message("CSV saved: atc_data/WHO_ATC_Hierarchy_", Sys.Date(), ".csv")
```

# Create the cleaned version

```{r}
# Step 1: Select only main categories (ATC codes with 1–5 digits)
atc_headings <- all_atc %>%
  filter(nchar(atc_code) <= 5) 

# Helper: join in the ATC heading at a specific level
join_atc_heading <- function(data, headings, level_len, new_name, by_col) {
  data %>%
    left_join(
      headings %>%
        filter(nchar(atc_code) == level_len) %>%
        rename(!!new_name := atc_name),
      by = setNames("atc_code", by_col)
    )
}

# Main pipeline
atc_levels <- all_atc %>%
  filter(nchar(atc_code) > 5) %>%
  mutate(
    atc_level_01 = substr(atc_code, 1, 1),
    atc_level_03 = substr(atc_code, 1, 3),
    atc_level_04 = substr(atc_code, 1, 4),
    atc_level_05 = substr(atc_code, 1, 5)
  ) %>%
  join_atc_heading(atc_headings, 1, "anatomical_main_group_01", "atc_level_01") %>%
  join_atc_heading(atc_headings, 3, "therapeutic_subgroup_02", "atc_level_03") %>%
  join_atc_heading(atc_headings, 4, "pharmacological_subgroup_03", "atc_level_04") %>%
  join_atc_heading(atc_headings, 5, "chemical_subgroup_04", "atc_level_05") %>%
  rename(chemical_substance = atc_name) %>%
  distinct(atc_code, .keep_all = TRUE) %>%
  select(atc_level_01, anatomical_main_group_01, atc_level_03, therapeutic_subgroup_02, atc_level_04, pharmacological_subgroup_03, atc_level_05, chemical_subgroup_04, atc_code, chemical_substance)


# this is the nice file I want:
write_csv(atc_levels, paste0("atc_data/WHO_ATC_Hierarchy_wide_", Sys.Date(), ".csv"))
```

### Read atc_levels

```{r}
# read:
atc_levels <- WHO_ATC_Hierarchy_wide_2025_09_16 <- read_csv("atc_data/WHO_ATC_Hierarchy_wide_2025-09-16.csv")
```

# Prepare plot

Next, turn it into a dataframe in the format that can be used for the plotly sunburst plot:

```{r}
# I need a little work-around to get the format I need. Might be better ways out there
# original code version:
df <- atc_levels %>%
  mutate(value = 1) %>%
  select(atc_level_01, atc_level_03, atc_level_04, atc_level_05, atc_code, chemical_substance, value)

# text version:
df_text <- atc_levels %>%
  mutate(value = 1) %>%
  select(anatomical_main_group_01, therapeutic_subgroup_02, pharmacological_subgroup_03, chemical_subgroup_04, atc_code, chemical_substance, value)


```

### ismirsehregal's solution to get the right plotly format for a sunburst plot

Getting the correct format:

```{r}
# From ismirsehregal on Stackoverflow:

create_sunburst_data_format <- function(DF_plotly, value_column = NULL, add_root = FALSE, drop_na_nodes = TRUE){
  colNamesDF_plotly <- names(DF_plotly)
  
  if(is.data.table(DF_plotly)){
    DT <- copy(DF_plotly)
  } else {
    DT <- data.table(DF_plotly, stringsAsFactors = FALSE)
  }
  
  if(add_root){
    DT[, root := "Total"]  
  }
  
  colNamesDT <- names(DT)
  hierarchy_columns <- setdiff(colNamesDT, value_column)
  numeric_hierarchy_columns <- names(which(unlist(lapply(DT, is.numeric))))
  
  if(is.null(value_column) && add_root){
    setcolorder(DT, c("root", colNamesDF_plotly))
  } else if(!is.null(value_column) && !add_root) {
    setnames(DT, value_column, "values", skip_absent=TRUE)
    setcolorder(DT, c(setdiff(colNamesDF_plotly, value_column), "values"))
  } else if(!is.null(value_column) && add_root) {
    setnames(DT, value_column, "values", skip_absent=TRUE)
    setcolorder(DT, c("root", setdiff(colNamesDF_plotly, value_column), "values"))
  }
  
  for(current_column in setdiff(numeric_hierarchy_columns, c("root", value_column))){
    DT[, (current_column) := apply(.SD, 1, function(x){fifelse(is.na(x), yes = NA_character_, no = toTitleCase(gsub("_"," ", paste(names(x), x, sep = ": ", collapse = " | "))))}), .SDcols = current_column]
  }
  
  hierarchyList <- list()
  for(i in seq_along(hierarchy_columns)){
    current_columns <- colNamesDT[1:i]
    
    if(is.null(value_column)){
      currentDT <- unique(DT[, ..current_columns][, values := .N, by = current_columns], by = current_columns)
    } else {
      currentDT <- DT[, lapply(.SD, sum, na.rm = TRUE), by=current_columns, .SDcols = "values"]
    }
    
    setnames(currentDT, length(current_columns), "labels")
    currentDT[, depth := length(current_columns)-1]
    hierarchyList[[i]] <- currentDT
  }
  
  hierarchyDT <- rbindlist(hierarchyList, use.names = TRUE, fill = TRUE)
  
  if(drop_na_nodes){
    hierarchyDT <- na.omit(hierarchyDT, cols = "labels")
    parent_columns <- setdiff(names(hierarchyDT), c("labels", "values", "depth", value_column))
    hierarchyDT[, parents := apply(.SD, 1, function(x){fifelse(all(is.na(x)), yes = NA_character_, no = paste(x[!is.na(x)], sep = ":", collapse = " - "))}), .SDcols = parent_columns]
  } else {
    parent_columns <- setdiff(names(hierarchyDT), c("labels", "values", value_column))
    hierarchyDT[, parents := apply(.SD, 1, function(x){fifelse(x["depth"] == "0", yes = NA_character_, no = paste(x[seq(2, as.integer(x["depth"])+1)], sep = ":", collapse = " - "))}), .SDcols = parent_columns]
  }
  
  hierarchyDT[, ids := apply(.SD, 1, function(x){paste(c(if(is.na(x["parents"])){NULL}else{x["parents"]}, x["labels"]), collapse = " - ")}), .SDcols = c("parents", "labels")]
  hierarchyDT[, union(parent_columns, "depth") := NULL]
  
  return(hierarchyDT)
}

```

## Plotly

The plotly plot

```{r}
# Apply his function to the dataset:
hierarchyDF <- create_sunburst_data_format(df, value_column = "value", add_root = TRUE)

# To create the relevant hover information, the next step is a little unusual, probably a better solution out there:
hierarchyDF_text <- create_sunburst_data_format(df_text, value_column = "value", add_root = TRUE) %>%
  mutate(
    hover_info = sapply(ids, function(x) {
      parts <- str_split(x, " - ")[[1]]   # split by " - "
      str_trim(tail(parts, 1))            # take last segment, trim spaces
    })
  ) %>%
    mutate(hover_info = str_replace(hover_info, "^(.)", toupper))

# now we can use the hover info in the actual dataset we want to use::      
sunburst_df <- hierarchyDF %>%
  mutate(hover_info = hierarchyDF_text$hover_info) %>%
  arrange(desc(labels)) %>%
  mutate(hover_info = case_when(ids == "Total" ~ "ATC",
                                .default = hover_info),
         labels = case_when(ids == "Total" ~ "ATC",
                                .default = labels))


p <- plot_ly(
  sunburst_df,
  ids = ~ids,
  labels = ~labels,
  parents = ~parents,
  values = ~values,
  type = "sunburst",
  branchvalues = "total",
  hovertext = ~hover_info,   # <- point to your custom column
  hoverinfo = "text", 
  sort = FALSE,
  rotation = 90)   # rotate 90 degrees clockwise, so top is north

p
```

Save the html:

```{r}
# Export as HTML
saveWidget(
  p,
  file = "ATC_Sunburst.html",
  selfcontained = TRUE
)

message("Interactive sunburst exported to output/ATC_Sunburst.html")
```

## EMA indications

Next it would be nice if I could add indication to the hover information:

```{r}
ema_medicines_raw <- medicines_output_medicines_en_2 <- read_excel("medicines data/medicines_output_medicines_en-2.xlsx", range = "A09:P1100")

ema_medicines <- ema_medicines_raw %>%
  janitor::clean_names()  %>%
  select(name_of_medicine, active_substance, atc_code_human, therapeutic_indication) %>%
  mutate(active_substance = str_to_lower(active_substance), 
         therapeutic_indication = str_replace_all(therapeutic_indication, "(.{1,60})(\\s|$)", "\\1<br>")) %>%
  distinct(name_of_medicine, .keep_all = TRUE)
  
```

See if I can add it to the plot:

```{r}
sunburst_df <- hierarchyDF %>%
  mutate(hover_info = hierarchyDF_text$hover_info) %>%
  arrange(desc(labels)) %>%
  left_join(ema_medicines, join_by(labels == active_substance)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  mutate(hover_info = case_when(ids == "Total" ~ "ATC",
                                !is.na(therapeutic_indication) ~ therapeutic_indication,
                                .default = hover_info),
         labels = case_when(ids == "Total" ~ "ATC",
                                .default = labels)) 

sum(is.na(sunburst_df$therapeutic_indication))
```

I could also try to join earlier:

```{r}

# two ways to join:
atc_ema_atc_join <- atc_levels %>%
  left_join(ema_medicines %>% 
              select(atc_code_human, name_of_medicine) %>%
              filter(nchar(atc_code_human) == 7), 
  join_by(atc_code == atc_code_human)) %>%
  distinct(atc_code, chemical_substance, name_of_medicine, .keep_all = TRUE)

atc_ema_substance_join <- atc_levels %>%  
  left_join(ema_medicines %>%
              select(name_of_medicine, active_substance), 
            join_by(chemical_substance == active_substance)) %>%
    distinct(atc_code, chemical_substance, name_of_medicine, .keep_all = TRUE)

atc_ema <- bind_rows(atc_ema_atc_join, atc_ema_substance_join) %>%
  distinct(atc_code, chemical_substance, name_of_medicine, .keep_all = TRUE)

# Did it matter? One way to check is to do this:
anti_join(atc_ema_atc_join, atc_ema_substance_join)
anti_join(atc_ema_substance_join, atc_ema_atc_join)
# turns out it was good I joined by boh eethods.
```

```{r}
# original code version:
df <- atc_ema %>%
  mutate(value = 1) %>%
  select(atc_level_01, atc_level_03, atc_level_04, atc_level_05, atc_code, chemical_substance, name_of_medicine, value)

# text version:
df_text <- atc_ema %>%
  mutate(value = 1) %>%
  select(anatomical_main_group_01, therapeutic_subgroup_02, pharmacological_subgroup_03, chemical_subgroup_04, atc_code, chemical_substance, name_of_medicine, value)


```

```{r}
hierarchyDF <- create_sunburst_data_format(df, value_column = "value", add_root = TRUE)

# the next step is a little unusual, probably a better solution out there:
hierarchyDF_text <- create_sunburst_data_format(df_text, value_column = "value", add_root = TRUE) %>%
  mutate(
    hover_info = sapply(ids, function(x) {
      parts <- str_split(x, " - ")[[1]]   # split by " - "
      str_trim(tail(parts, 1))            # take last segment, trim spaces
    })
  ) %>%
    mutate(hover_info = str_replace(hover_info, "^(.)", toupper))
```

```{r}
sunburst_df <- hierarchyDF %>%
  mutate(hover_info = hierarchyDF_text$hover_info) %>%
  arrange(desc(labels)) %>%
  left_join(ema_medicines, join_by(labels == name_of_medicine)) %>%
  distinct(ids, .keep_all = TRUE) %>%
  mutate(hover_info = case_when(ids == "Total" ~ "ATC",
                                !is.na(therapeutic_indication) ~ therapeutic_indication,
                                .default = hover_info),
         labels = case_when(ids == "Total" ~ "ATC",
                                .default = labels)) 
```

```{r}
p_ema <- plot_ly(
  sunburst_df,
  ids = ~ids,
  labels = ~labels,
  parents = ~parents,
  values = ~values,
  type = "sunburst",
  branchvalues = "total",
  hovertext = ~hover_info,   # <- point to your custom column
  hoverinfo = "text", 
  sort = FALSE,
  rotation = 90)   # rotate 90 degrees clockwise, so top is north

p_ema
```

```{r}
# Export as HTML
saveWidget(
  p_ema,
  file = "ATC_centralised_Sunburst.html",
  selfcontained = TRUE
)

message("Interactive sunburst exported to output/ATC_centralised_Sunburst.html")
```
